<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jm0820.github.io</id>
    <title>小王同学</title>
    <updated>2020-03-19T15:46:56.977Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jm0820.github.io"/>
    <link rel="self" href="https://jm0820.github.io/atom.xml"/>
    <subtitle>永远废物，永远混吃等死</subtitle>
    <logo>https://jm0820.github.io/images/avatar.png</logo>
    <icon>https://jm0820.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 小王同学</rights>
    <entry>
        <title type="html"><![CDATA[Servlet ]]></title>
        <id>https://jm0820.github.io/post/servlet/</id>
        <link href="https://jm0820.github.io/post/servlet/">
        </link>
        <updated>2020-03-19T15:40:33.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="简介">简介</h1>
<h3 id="什么是servlet">什么是Servlet</h3>
<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，也就是一个java  类，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<h3 id="servlet-架构">Servlet 架构</h3>
<ul>
<li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li>
<li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li>
<li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。<br>
<img src="https://img-blog.csdnimg.cn/20200319220625302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FseXNvbl9qbQ==,size_16,color_FFFFFF,t_70" alt="servlet 架构图" loading="lazy"></li>
</ul>
<h3 id="servlet-任务">Servlet 任务</h3>
<ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<h3 id="生命周期">生命周期</h3>
<p>Servlet 的生命周期是由Web 容器来管理的。</p>
<ul>
<li>Servlet 通过调用 init () 方法进行初始化。</li>
</ul>
<pre><code>public void init(ServletConfig servletConfig)
</code></pre>
<p>只被调用一次，在创建好实例后立即被调用，用于初始化当前Servlet</p>
<ul>
<li>Servlet 调用 service() 方法来处理客户端的请求。</li>
</ul>
<pre><code>public void service(ServletRequest servletRequest, ServletResponse servletResponse)
</code></pre>
<p>一般来说service 方法处理具体业务的，每次访问都会被调用，是多线程的。</p>
<ul>
<li>Servlet 通过调用 destroy() 方法终止（结束）。</li>
</ul>
<pre><code>public void destroy()
</code></pre>
<p>destory 是销毁方法，每次当Servlet 服务器关闭时调用。</p>
<ul>
<li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ul>
<h3 id="servlet-容器相应客户请求的过程">Servlet 容器相应客户请求的过程</h3>
<ol>
<li>Servlet 引擎检查是否已经装载并创建了该Servlet 的实例对象，如果是，则执行第④步，否则执行第②步。</li>
<li>装载并创建该Servlet 的一个实例对象：调用该Servlet 的构造器。</li>
<li>创建一个用于封装请求的ServletRequest 对象和一个代表响应消息的ServletReqsponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</li>
<li>WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet,并在卸载之前调用Servlet 的destory()方法。</li>
</ol>
<h1 id="servlet-使用">Servlet 使用</h1>
<p>准备条件：<br>
引入servlet 的jar 包</p>
<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
      &lt;version&gt;3.1.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
<p><strong>新建一个Servlet</strong><br>
有三种新建Servlet 的方法</p>
<ul>
<li>实现 Servlet 接口</li>
<li>继承 GenericServlet抽象类</li>
<li>继承 HttpSerevlet 类（开发中常用的方法）<br>
这里实现 Servlet 接口来新建一个Servlet.</li>
</ul>
<pre><code>public class HelloServlet implements Servlet {

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println(&quot;init&quot;);
    }

    /**
     * ServletConfig :封装了Servlet 的配置信息，并且可以获取ServleteContext 对象
     *
     */
    @Override
    public ServletConfig getServletConfig() {
        System.out.println(&quot;getServletConfig&quot;);
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println(&quot;service&quot;);
    }

    @Override
    public String getServletInfo() {
        System.out.println(&quot;getServletInfo&quot;);
        return null;
    }

    @Override
    public void destroy() {
        System.out.println(&quot;destroy&quot;);
    }

    public HelloServlet() {
        System.out.println(&quot;HelloServlet constuct&quot;);
    }
}
</code></pre>
<p><strong>注册Servlet</strong><br>
Servlet 程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet 引擎加载和被外界访问</p>
<pre><code>&lt;!--配置和映射Servlet--&gt;
  &lt;servlet&gt;
    &lt;!--Servlet 注册的名字--&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;!--Servlet 的全类名--&gt;
    &lt;servlet-class&gt;com.atguigu.HelloServlet&lt;/servlet-class&gt;
    &lt;!--可以指定servlet被创建的时机--&gt;
    &lt;!--&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;--&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;!--需要和某个Servlet 节点的Servlet-name子节点一致--&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;!--映射具体的访问路径，/代表当前web应用的根目录--&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<p>Servlet 映射细节</p>
<ul>
<li>一个Servlet 可以被映射到多个url,即多个<servlet-mapping>元素的<servlet-name>子元素的设置值可以是同一个Servlet 的注册名</li>
</ul>
<pre><code>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;!--映射具体的访问路径
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<p>在这个例子中访问hello 和hello2 都调用的是 hello 这个servlet</p>
<ul>
<li>在Servlet 映射到的URL中也可以使用<em>通配符，但是只能有两种固定的格式：一种格式是“</em>.扩展名”，另一种格式是以政正斜杠/开头并以“/*”结尾</li>
</ul>
<pre><code>*.html   *.do   *.jsp
/action/*   以/action/ 开头的请求都可以访问
</code></pre>
<p>斜杠和扩展名不能同时存在,下面这个例子就是不合法的</p>
<pre><code>/.html
</code></pre>
<p>注册Servlet 有另外一种方式，除了web.xml配置，还可以使用注解。</p>
<pre><code>@WebServlet(&quot;/hello&quot;)
</code></pre>
<p>在待注册的Servlet加上注解，通过访问注解里的url来访问 Servlet</p>
<p><strong>在tomcat 服务器中运行的结果</strong></p>
<pre><code>HelloServlet constuct
init
service
destroy
</code></pre>
<h1 id="servlet-的四大域对象">Servlet 的四大域对象</h1>
<p>servlet 有九个内置对象，分别为：<strong>pageContext、ServletRequest、HttpSession、ServletContext</strong></p>
<p>所有域对象都是有存取数据的功能，因为域对象内部有一个Map，用来存储数据，下面是ServletContext对象用来操作数据的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void setAttribute(String name,Object val)</td>
<td style="text-align:center">用来存储一个对象，也可以成为存储一个域，参数分别为域的属性名和属性值，如果多次调用该方法，并且使用相同的name，那么就会覆盖上一次的值，这一特性与Map相似</td>
</tr>
<tr>
<td style="text-align:center">Object getAttribute(String     name)</td>
<td style="text-align:center">用来获取ServletContext中的数据，当前在获取之前需要先存储。</td>
</tr>
<tr>
<td style="text-align:center">void removeAttribute(String name)</td>
<td style="text-align:center">用来移除ServletContext中的域属性，如果参数name不存在，那么该方法什么都不做</td>
</tr>
<tr>
<td style="text-align:center">Enumeration getAttributeNames()</td>
<td style="text-align:center">获取所有域属性的名称</td>
</tr>
</tbody>
</table>
<p><strong>一、pageContext</strong><br>
pageContext 是Jsp 页面中才有的对象。</p>
<ul>
<li>生命周期<br>
当对JSP请求时创建，当响应结束时销毁</li>
<li>作用范围<br>
整个JSP页面，是四大域中最小的一个。</li>
<li>作用<br>
pageContext 对象封装了8大隐式对象，通过它可以获得其它的8个对象</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getException()</td>
<td style="text-align:center">返回Exception</td>
</tr>
<tr>
<td style="text-align:center">getPage()</td>
<td style="text-align:center">返回Page</td>
</tr>
<tr>
<td style="text-align:center">getRequest()</td>
<td style="text-align:center">返回request</td>
</tr>
<tr>
<td style="text-align:center">getResponse()</td>
<td style="text-align:center">返回response</td>
</tr>
<tr>
<td style="text-align:center">getServletConfig()</td>
<td style="text-align:center">返回config</td>
</tr>
<tr>
<td style="text-align:center">getServletContext()</td>
<td style="text-align:center">返回application</td>
</tr>
<tr>
<td style="text-align:center">getSession()</td>
<td style="text-align:center">返回session</td>
</tr>
<tr>
<td style="text-align:center">getOut()</td>
<td style="text-align:center">返回out</td>
</tr>
</tbody>
</table>
<p><strong>二、Servletrequest</strong></p>
<ul>
<li>生命周期<br>
在service方法调用前由服务器创建，传入service()方法，整个请求结束，ServletRequest生命周期结束。</li>
<li>作用范围<br>
仅在当前请求中有效，请求的转发也是一个请求。</li>
<li>作用<br>
常用语服务器间同一请求不同页面之间的参数传递，常用语表单的控件值传递。</li>
</ul>
<blockquote>
<p>扩展<br>
HttpServletRequest:是ServletRequest 的子接口，针对于HTTP请求所定义，里面包含了大量获取HTTP请求相关的方法。</p>
<ul>
<li>获取请求的URL<br>
HttpServletRequest.getRequestURI()</li>
<li>获取请求方式<br>
HttpServletRequest.getMethod()</li>
<li>若是一个get请求，获取请求参数的字符串，若是post 请求，则结果为null<br>
HttpServletRequest.getQueryString</li>
<li>获取请求的Servlet 映射路径<br>
HttpServletRequest.getServletPath</li>
</ul>
</blockquote>
<p><strong>三、HttpSession</strong></p>
<ul>
<li>生命周期<br>
服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。<br>
在第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有就在内存中创建一个并返回。<br>
当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。如果服务器非正常关闭（强行关闭），还未到期的session也会被销毁。<br>
另外，调用session的invalidate()方法可以立即销毁session。</li>
<li>作用范围<br>
一次会话</li>
<li>作用<br>
常用于web开发中的登录验证界面（当用户登陆成功后浏览器分配其中一个Session键值对）。</li>
</ul>
<p><strong>四、ServletContext</strong></p>
<ul>
<li>生命周期<br>
当web应用被加进容器时，创建代表整个web应用的ServletContext对象，当服务器关闭，或web应用被移除时，ServletContext对象跟着被销毁。</li>
<li>作用范围<br>
整个web应用</li>
<li>作用
<ul>
<li>由于一个web应用中的所有Servlet共享同一个ServletContext对象：因此Servlet对象之间可以通过ServletContext来是实现通讯。ServletContext对象通常也被称为context域对象</li>
<li>获取WEB应用程序的初始化参数<br>
配置参数</li>
</ul>
<pre><code>&lt;!--配置当前 web 应用的初始化参数--&gt;
&lt;context-param&gt;
  &lt;param-name&gt;driver&lt;/param-name&gt;
  &lt;param-value&gt;com.mysql.jdbc.driver&lt;/param-value&gt;
&lt;/context-param&gt;


&lt;context-param&gt;
  &lt;param-name&gt;jdbcUrl&lt;/param-name&gt;
  &lt;param-value&gt;jdbc:mysql:///atguigu&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
获初始化参数<pre><code>//获取ServletContext 对象
ServletContext context = servletConfig.getServletContext();


String driver = context.getInitParameter(&quot;driver&quot;);
System.out.println(&quot;driver:&quot;+driver);


Enumeration&lt;String&gt; ns = context.getInitParameterNames();
while(ns.hasMoreElements()){
    String name = ns.nextElement();
    System.out.println(&quot;----&gt;&quot;+name);
}
</code></pre>
<ul>
<li>记录日志</li>
<li>application 域范围的属性</li>
<li>访问资源文件<code>context.getResourceAsStream(&quot;jdbc.properties&quot;)</code></li>
<li>获取虚拟路径所映射的本地路径<code>getRealPath(&quot;/note.txt&quot;)</code></li>
<li>获取当前WEB应用的名称<code>getContextPath()</code></li>
<li>WEB应用程序之间的访问</li>
<li>SerevletContext的其它方法</li>
</ul>
</li>
</ul>
<h1 id="servlet-的转发和重定向">Servlet 的转发和重定向</h1>
<p>请求的转发和跳转都是为了实现页面的跳转.</p>
<h3 id="转发">转发</h3>
<p>假设浏览器访问servlet1，而servlet1想让servlet2为客户端服务。此时servlet1调用forward（）方法，将请求转发给servlet2。但是调用forward()方法，对于浏览器来说是透明的，浏览器并不知道为其服务的Servlet已经换成Servlet2，它只知道发出了一个请求，获得了一个响应。浏览器URL的地址栏不变。<br>
转发的对象是RequestDispatcher,有两种方式可以获取到这个对象</p>
<ul>
<li>HttpservletRequest的getRequestDispatcher()</li>
<li>ServletContext 的getRequestDispatcher()</li>
</ul>
<pre><code>//1.调用HttpServletRequest 的getRequestDispatcher()获取RequestDispatcher 对象
//调用getRequestDispatcher()想要传入要转发的地址
String path = &quot;testServlet1&quot;;
RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/&quot; + path);
//2.调用HttpServletRequest 的forward(request,response)进行请求的转发
requestDispatcher.forward(req,resp);
</code></pre>
<h3 id="重定向">重定向</h3>
<p>浏览器访问servlet1,而servlet1 想让servlet2 为客户端服务，此时servlet1 调用sendRedirect()将请求重定向到Servlet2.接着浏览器访问servlet2,servlet2 对客户段请求做出反应，浏览器的URL地址改变</p>
<pre><code>//执行请求的重定向，直接调用response.sendRedirect(path)方法
//path 为要重定向的地址
String path = &quot;testServlet1&quot;;
resp.sendRedirect(path);
</code></pre>
<h3 id="转发和重定向的区别">转发和重定向的区别</h3>
<p><strong>本质区别</strong><br>
请求的转发是只发出了一次请求，而重定向则发出了两次请求。</p>
<p><strong>具体区别</strong><br>
请求转发:地址栏是初次发出请求的地址<br>
请求重定向：地址栏不再是初次发出的请求地址地址栏为最后响应的那个地址</p>
<p>请求转发：在最终的Servlet 中，request 对象和中转的那个request 是同一个对象<br>
请求重定向：在最终的Servlet 中，request 对象和中转的那个request 不是同一个对象</p>
<p>请求转发：只能转发给当前WEB应用的资源<br>
请求重定向：可以重定向到任何资源</p>
<p>请求转发：/代表的是当前WEB应用的根目录   <code>http://localhost:8080/project/</code><br>
请求重定向：/代表的是当前WEB站点的根目录<code>http://localhost:8080/</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一个博客]]></title>
        <id>https://jm0820.github.io/post/di-yi-ge-bo-ke/</id>
        <link href="https://jm0820.github.io/post/di-yi-ge-bo-ke/">
        </link>
        <updated>2020-03-18T06:41:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="hello-world">Hello World</h3>
<h3 id="小王同学正在试试搞一个属于自己的博客">小王同学正在试试搞一个属于自己的博客</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://jm0820.github.io/post/hello-gridea/</id>
        <link href="https://jm0820.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>