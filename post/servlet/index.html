<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Servlet  | 小王同学</title>
<link rel="shortcut icon" href="https://jm0820.github.io/favicon.ico?v=1590746203892">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://jm0820.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Servlet  | 小王同学 - Atom Feed" href="https://jm0820.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Servlet 简介
什么是Servlet
Java Servlet 是运行在 Web 服务器或应用服务器上的程序，也就是一个java  类，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序..." />
    <meta name="keywords" content="Java WEB" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://jm0820.github.io">
  <img class="avatar" src="https://jm0820.github.io/images/avatar.png?v=1590746203892" alt="">
  </a>
  <h1 class="site-title">
    小王同学
  </h1>
  <p class="site-description">
    永远废物，永远混吃等死
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Servlet 
            </h2>
            <div class="post-info">
              <span>
                2020-03-19
              </span>
              <span>
                17 min read
              </span>
              
                <a href="https://jm0820.github.io/tag/lue2VfI4E/" class="post-tag">
                  # Java WEB
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="servlet-简介">Servlet 简介</h1>
<p><strong>什么是Servlet</strong><br>
Java Servlet 是运行在 Web 服务器或应用服务器上的程序，也就是一个java  类，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<p><strong>Servlet 架构</strong></p>
<ul>
<li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li>
<li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li>
<li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。<br>
<img src="https://img-blog.csdnimg.cn/20200319220625302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FseXNvbl9qbQ==,size_16,color_FFFFFF,t_70" alt="servlet 架构图" loading="lazy"><br>
<strong>Servlet 任务</strong></li>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户s端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<p><strong>生命周期</strong></p>
<p>Servlet 的生命周期是由Web 容器来管理的。</p>
<ul>
<li>Servlet 通过调用 init () 方法进行初始化。</li>
</ul>
<pre><code>public void init(ServletConfig servletConfig)
</code></pre>
<p>只被调用一次，在创建好实例后立即被调用，用于初始化当前Servlet</p>
<ul>
<li>Servlet 调用 service() 方法来处理客户端的请求。</li>
</ul>
<pre><code>public void service(ServletRequest servletRequest, ServletResponse servletResponse)
</code></pre>
<p>一般来说service 方法处理具体业务的，每次访问都会被调用，是多线程的。</p>
<ul>
<li>Servlet 通过调用 destroy() 方法终止（结束）。</li>
</ul>
<pre><code>public void destroy()
</code></pre>
<p>destory 是销毁方法，每次当Servlet 服务器关闭时调用。</p>
<ul>
<li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ul>
<p><strong>Servlet 容器响应客户请求的过程</strong></p>
<ol>
<li>Servlet 引擎检查是否已经装载并创建了该Servlet 的实例对象，如果是，则执行第④步，否则执行第②步。</li>
<li>装载并创建该Servlet 的一个实例对象：调用该Servlet 的构造器。</li>
<li>创建一个用于封装请求的ServletRequest 对象和一个代表响应消息的ServletReqsponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。</li>
<li>WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet,并在卸载之前调用Servlet 的destory()方法。</li>
</ol>
<h1 id="servlet-使用">Servlet 使用</h1>
<p>准备条件：<br>
引入servlet 的jar 包</p>
<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
      &lt;version&gt;3.1.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
<p><strong>新建一个Servlet</strong><br>
有三种新建Servlet 的方法</p>
<ul>
<li>实现 Servlet 接口</li>
<li>继承 GenericServlet抽象类</li>
<li>继承 HttpSerevlet 类（开发中常用的方法）<br>
这里实现 Servlet 接口来新建一个Servlet.</li>
</ul>
<pre><code>public class HelloServlet implements Servlet {

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println(&quot;init&quot;);
    }

    /**
     * ServletConfig :封装了Servlet 的配置信息，并且可以获取ServleteContext 对象
     *
     */
    @Override
    public ServletConfig getServletConfig() {
        System.out.println(&quot;getServletConfig&quot;);
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println(&quot;service&quot;);
    }

    @Override
    public String getServletInfo() {
        System.out.println(&quot;getServletInfo&quot;);
        return null;
    }

    @Override
    public void destroy() {
        System.out.println(&quot;destroy&quot;);
    }

    public HelloServlet() {
        System.out.println(&quot;HelloServlet constuct&quot;);
    }
}
</code></pre>
<p><strong>注册Servlet</strong><br>
Servlet 程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet 引擎加载和被外界访问</p>
<pre><code>&lt;!--配置和映射Servlet--&gt;
  &lt;servlet&gt;
    &lt;!--Servlet 注册的名字--&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;!--Servlet 的全类名--&gt;
    &lt;servlet-class&gt;com.atguigu.HelloServlet&lt;/servlet-class&gt;
    &lt;!--可以指定servlet被创建的时机--&gt;
    &lt;!--&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;--&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;!--需要和某个Servlet 节点的Servlet-name子节点一致--&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;!--映射具体的访问路径，/代表当前web应用的根目录--&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<p>Servlet 映射细节</p>
<ul>
<li>一个Servlet 可以被映射到多个url,即多个<servlet-mapping>元素的<servlet-name>子元素的设置值可以是同一个Servlet 的注册名</li>
</ul>
<pre><code>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;
    &lt;!--映射具体的访问路径
    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<p>在这个例子中访问hello 和hello2 都调用的是 hello 这个servlet</p>
<ul>
<li>在Servlet 映射到的URL中也可以使用<em>通配符，但是只能有两种固定的格式：一种格式是“</em>.扩展名”，另一种格式是以政正斜杠/开头并以“/*”结尾</li>
</ul>
<pre><code>*.html   *.do   *.jsp
/action/*   以/action/ 开头的请求都可以访问
</code></pre>
<p>斜杠和扩展名不能同时存在,下面这个例子就是不合法的</p>
<pre><code>/.html
</code></pre>
<p>注册Servlet 有另外一种方式，除了web.xml配置，还可以使用注解。</p>
<pre><code>@WebServlet(&quot;/hello&quot;)
</code></pre>
<p>在待注册的Servlet加上注解，通过访问注解里的url来访问 Servlet</p>
<p><strong>在tomcat 服务器中运行的结果</strong></p>
<pre><code>HelloServlet constuct
init
service
destroy
</code></pre>
<h1 id="servlet-的四大域对象">Servlet 的四大域对象</h1>
<p>servlet 有九个内置对象，分别为：<strong>pageContext、ServletRequest、HttpSession、ServletContext</strong></p>
<p>所有域对象都是有存取数据的功能，因为域对象内部有一个Map，用来存储数据，下面是ServletContext对象用来操作数据的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void setAttribute(String name,Object val)</td>
<td style="text-align:center">用来存储一个对象，也可以成为存储一个域，参数分别为域的属性名和属性值，如果多次调用该方法，并且使用相同的name，那么就会覆盖上一次的值，这一特性与Map相似</td>
</tr>
<tr>
<td style="text-align:center">Object getAttribute(String     name)</td>
<td style="text-align:center">用来获取ServletContext中的数据，当前在获取之前需要先存储。</td>
</tr>
<tr>
<td style="text-align:center">void removeAttribute(String name)</td>
<td style="text-align:center">用来移除ServletContext中的域属性，如果参数name不存在，那么该方法什么都不做</td>
</tr>
<tr>
<td style="text-align:center">Enumeration getAttributeNames()</td>
<td style="text-align:center">获取所有域属性的名称</td>
</tr>
</tbody>
</table>
<p><strong>一、pageContext</strong><br>
pageContext 是Jsp 页面中才有的对象。</p>
<ul>
<li>生命周期<br>
当对JSP请求时创建，当响应结束时销毁</li>
<li>作用范围<br>
整个JSP页面，是四大域中最小的一个。</li>
<li>作用<br>
pageContext 对象封装了8大隐式对象，通过它可以获得其它的8个对象</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getException()</td>
<td style="text-align:center">返回Exception</td>
</tr>
<tr>
<td style="text-align:center">getPage()</td>
<td style="text-align:center">返回Page</td>
</tr>
<tr>
<td style="text-align:center">getRequest()</td>
<td style="text-align:center">返回request</td>
</tr>
<tr>
<td style="text-align:center">getResponse()</td>
<td style="text-align:center">返回response</td>
</tr>
<tr>
<td style="text-align:center">getServletConfig()</td>
<td style="text-align:center">返回config</td>
</tr>
<tr>
<td style="text-align:center">getServletContext()</td>
<td style="text-align:center">返回application</td>
</tr>
<tr>
<td style="text-align:center">getSession()</td>
<td style="text-align:center">返回session</td>
</tr>
<tr>
<td style="text-align:center">getOut()</td>
<td style="text-align:center">返回out</td>
</tr>
</tbody>
</table>
<p><strong>二、Servletrequest</strong></p>
<ul>
<li>生命周期<br>
在service方法调用前由服务器创建，传入service()方法，整个请求结束，ServletRequest生命周期结束。</li>
<li>作用范围<br>
仅在当前请求中有效，请求的转发也是一个请求。</li>
<li>作用<br>
常用语服务器间同一请求不同页面之间的参数传递，常用语表单的控件值传递。</li>
</ul>
<blockquote>
<p>扩展<br>
HttpServletRequest:是ServletRequest 的子接口，针对于HTTP请求所定义，里面包含了大量获取HTTP请求相关的方法。</p>
<ul>
<li>获取请求的URL<br>
HttpServletRequest.getRequestURI()</li>
<li>获取请求方式<br>
HttpServletRequest.getMethod()</li>
<li>若是一个get请求，获取请求参数的字符串，若是post 请求，则结果为null<br>
HttpServletRequest.getQueryString</li>
<li>获取请求的Servlet 映射路径<br>
HttpServletRequest.getServletPath</li>
</ul>
</blockquote>
<p><strong>三、HttpSession</strong></p>
<ul>
<li>生命周期<br>
服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。<br>
在第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有就在内存中创建一个并返回。<br>
当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。如果服务器非正常关闭（强行关闭），还未到期的session也会被销毁。<br>
另外，调用session的invalidate()方法可以立即销毁session。</li>
<li>作用范围<br>
一次会话</li>
<li>作用<br>
常用于web开发中的登录验证界面（当用户登陆成功后浏览器分配其中一个Session键值对）。</li>
</ul>
<p><strong>四、ServletContext</strong></p>
<ul>
<li>生命周期<br>
当web应用被加进容器时，创建代表整个web应用的ServletContext对象，当服务器关闭，或web应用被移除时，ServletContext对象跟着被销毁。</li>
<li>作用范围<br>
整个web应用</li>
<li>作用
<ul>
<li>由于一个web应用中的所有Servlet共享同一个ServletContext对象：因此Servlet对象之间可以通过ServletContext来是实现通讯。ServletContext对象通常也被称为context域对象</li>
<li>获取WEB应用程序的初始化参数<br>
配置参数</li>
</ul>
<pre><code>&lt;!--配置当前 web 应用的初始化参数--&gt;
&lt;context-param&gt;
  &lt;param-name&gt;driver&lt;/param-name&gt;
  &lt;param-value&gt;com.mysql.jdbc.driver&lt;/param-value&gt;
&lt;/context-param&gt;


&lt;context-param&gt;
  &lt;param-name&gt;jdbcUrl&lt;/param-name&gt;
  &lt;param-value&gt;jdbc:mysql:///atguigu&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
获初始化参数<pre><code>//获取ServletContext 对象
ServletContext context = servletConfig.getServletContext();


String driver = context.getInitParameter(&quot;driver&quot;);
System.out.println(&quot;driver:&quot;+driver);


Enumeration&lt;String&gt; ns = context.getInitParameterNames();
while(ns.hasMoreElements()){
    String name = ns.nextElement();
    System.out.println(&quot;----&gt;&quot;+name);
}
</code></pre>
<ul>
<li>记录日志</li>
<li>application 域范围的属性</li>
<li>访问资源文件<code>context.getResourceAsStream(&quot;jdbc.properties&quot;)</code></li>
<li>获取虚拟路径所映射的本地路径<code>getRealPath(&quot;/note.txt&quot;)</code></li>
<li>获取当前WEB应用的名称<code>getContextPath()</code></li>
<li>WEB应用程序之间的访问</li>
<li>SerevletContext的其它方法</li>
</ul>
</li>
</ul>
<h1 id="servlet-的转发和重定向">Servlet 的转发和重定向</h1>
<p>请求的转发和跳转都是为了实现页面的跳转.<br>
<strong>转发</strong><br>
假设浏览器访问servlet1，而servlet1想让servlet2为客户端服务。此时servlet1调用forward（）方法，将请求转发给servlet2。但是调用forward()方法，对于浏览器来说是透明的，浏览器并不知道为其服务的Servlet已经换成Servlet2，它只知道发出了一个请求，获得了一个响应。浏览器URL的地址栏不变。<br>
转发的对象是RequestDispatcher,有两种方式可以获取到这个对象</p>
<ul>
<li>HttpservletRequest的getRequestDispatcher()</li>
<li>ServletContext 的getRequestDispatcher()</li>
</ul>
<pre><code>//1.调用HttpServletRequest 的getRequestDispatcher()获取RequestDispatcher 对象
//调用getRequestDispatcher()想要传入要转发的地址
String path = &quot;testServlet1&quot;;
RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/&quot; + path);
//2.调用HttpServletRequest 的forward(request,response)进行请求的转发
requestDispatcher.forward(req,resp);
</code></pre>
<p><strong>重定向</strong><br>
浏览器访问servlet1,而servlet1 想让servlet2 为客户端服务，此时servlet1 调用sendRedirect()将请求重定向到Servlet2.接着浏览器访问servlet2,servlet2 对客户段请求做出反应，浏览器的URL地址改变</p>
<pre><code>//执行请求的重定向，直接调用response.sendRedirect(path)方法
//path 为要重定向的地址
String path = &quot;testServlet1&quot;;
resp.sendRedirect(path);
</code></pre>
<p><strong>转发和重定向的区别</strong></p>
<p><strong>本质区别</strong><br>
请求的转发是只发出了一次请求，而重定向则发出了两次请求。</p>
<p><strong>具体区别</strong><br>
请求转发:地址栏是初次发出请求的地址<br>
请求重定向：地址栏不再是初次发出的请求地址地址栏为最后响应的那个地址</p>
<p>请求转发：在最终的Servlet 中，request 对象和中转的那个request 是同一个对象<br>
请求重定向：在最终的Servlet 中，request 对象和中转的那个request 不是同一个对象</p>
<p>请求转发：只能转发给当前WEB应用的资源<br>
请求重定向：可以重定向到任何资源</p>
<p>请求转发：/代表的是当前WEB应用的根目录   <code>http://localhost:8080/project/</code><br>
请求重定向：/代表的是当前WEB站点的根目录<code>http://localhost:8080/</code></p>
<h1 id="genericservlet-和-httpservlet">GenericServlet 和 HttpServlet</h1>
<p><strong>一、GenericServelt</strong><br>
GenericServelt 是Servlet 接口的实现类，但它是一个抽象类</p>
<pre><code>public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {
</code></pre>
<p>它实现了Servlet、ServletConfig、Serializable 这几个接口。</p>
<ul>
<li>ServletConfig 接口</li>
</ul>
<pre><code>public interface ServletConfig {
    //得到Servlet的名字
    String getServletName();   
    
    //获取ServletContext对象
    ServletContext getServletContext();

    //获取初始化参数
    String getInitParameter(String var1);
    
    //获取初始化参数的Enumeration 对象
    Enumeration&lt;String&gt; getInitParameterNames();
}
</code></pre>
<p>GenericServlet内部有一个私有的ServletConfig 对象。</p>
<pre><code>private transient ServletConfig config;

</code></pre>
<p>通过这个对象实现了ServletConfig 的方法。</p>
<ul>
<li>Servlet<br>
GenericServelt 实现了 Servlet 的除service()外所有的方法，GenericServelt这个抽象类只有一个抽象方法就是service()，我们继承GenericServlet 去实现Servlet 的时候只需要实现service()就可以了。</li>
</ul>
<p><strong>init()和init(ServletConfig config)</strong></p>
<pre><code>    //这个方法是Serevlet 接口的方法。
    public void init(ServletConfig config) throws ServletException {
        this.config = config;
        this.init();
    }

    public void init() throws ServletException {
    }
</code></pre>
<p>init(ServletConfig coonfig) 方法是 Servlete 自带的方法，在初次访问这个方法时自动调用，我们如果想自己实现这个方法只需要实现init()方法就可以了。<br>
如果我们覆盖了init(ServletConfig coonfig)方法，那么config 就不会被初始化，调用ServletConfig 的时候就会出现空指针异常。</p>
<ul>
<li>自己实现的一个GenericServlet</li>
</ul>
<pre><code>public  abstract class MyGenericServlet implements Servlet,ServletConfig{
    private ServletConfig servletConfig;

    public void init(ServletConfig servletConfig) throws ServletException {
        this.servletConfig = servletConfig;
    }

    public ServletConfig getServletConfig() {
        return servletConfig;
    }

    public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException;

    public String getServletInfo() {

        return null;
    }

    public void destroy() {

    }

    /**
     * 以下方法为ServletConfig 接口的方法
     * @return
     */
    public String getServletName() {
        return servletConfig.getServletName();
    }

    public ServletContext getServletContext() {
        return servletConfig.getServletContext();
    }

    public String getInitParameter(String s) {

        return servletConfig.getInitParameter(s);
    }

    public Enumeration&lt;String&gt; getInitParameterNames() {

        return servletConfig.getInitParameterNames();
    }
}

</code></pre>
<p><strong>二、HttpServlet</strong><br>
HttpServlet 是专门针对于Http协议定义的一个Servlet基类，它也是一个抽象类，继承于GenericServlet.</p>
<pre><code>public abstract class HttpServlet extends GenericServlet {
</code></pre>
<p>所以我们只需要实现Service(SrevletReeqequest,ServletResponse)方法即可。Servlet 的参数是ServletRequest和ServletResponse,但是因为所有的请求都是HTTP请求，所以传给Service 的其实是HttpServletRequst和HttpServletResponse.如果使用HttpServletRequest和HttpServletResponse那么需要进行强转。</p>
<pre><code>public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        if (req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse) {
            HttpServletRequest request = (HttpServletRequest)req;
            HttpServletResponse response = (HttpServletResponse)res;
            this.service(request, response);
        } else {
            throw new ServletException(&quot;non-HTTP request or response&quot;);
        }
    }
</code></pre>
<p>在HttpServlet 类里面的<code>service()</code>方法进行了强转然后调用了<code>service(HttpServletRequest, HttpServletresponse);</code></p>
<pre><code>protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String method = req.getMethod();
        long lastModified;
        if (method.equals(&quot;GET&quot;)) {
            lastModified = this.getLastModified(req);
            if (lastModified == -1L) {
                this.doGet(req, resp);
            } else {
                long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);
                if (ifModifiedSince &lt; lastModified) {
                    this.maybeSetLastModified(resp, lastModified);
                    this.doGet(req, resp);
                } else {
                    resp.setStatus(304);
                }
            }
        } else if (method.equals(&quot;HEAD&quot;)) {
            lastModified = this.getLastModified(req);
            this.maybeSetLastModified(resp, lastModified);
            this.doHead(req, resp);
        } else if (method.equals(&quot;POST&quot;)) {
            this.doPost(req, resp);
        } else if (method.equals(&quot;PUT&quot;)) {
            this.doPut(req, resp);
        } else if (method.equals(&quot;DELETE&quot;)) {
            this.doDelete(req, resp);
        } else if (method.equals(&quot;OPTIONS&quot;)) {
            this.doOptions(req, resp);
        } else if (method.equals(&quot;TRACE&quot;)) {
            this.doTrace(req, resp);
        } else {
            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
            Object[] errArgs = new Object[]{method};
            errMsg = MessageFormat.format(errMsg, errArgs);
            resp.sendError(501, errMsg);
        }

    }
</code></pre>
<p><code>service()</code> 会根据请求的方式来调用相应的方法，HttpServlet 里面写了相应的<code>doXXX()</code>方法.   我们在继承HttpServlet 实现Servlet 的时候只需要覆盖doXXX()方法即可.</p>
<p><strong>Http请求方法</strong></p>
<ul>
<li><code>GET</code>   通过请求URI得到资源</li>
<li><code>POST</code>   用于添加新的内容</li>
<li><code>PUT</code>   用于修改某个内容</li>
<li><code>DELETE</code>   删除某个内容</li>
<li><code>CONNECT</code>   用于代理进行传输，如使用SSL</li>
<li><code>OPTIONS</code>   询问可以执行哪些方法</li>
<li><code>PATCH</code>   部分文档更改</li>
<li><code>RACE</code>   用于远程诊断服务器</li>
<li><code>HEAD</code>   类似于GET, 但是不返回body信息，用于检查对象是否存在，以及得到对象的元数据</li>
<li><code>TRACE</code>   用于远程诊断服务器</li>
</ul>
<p><strong>自己实现一个HttpServlet</strong></p>
<pre><code>
/**
 * 针对 HTTP 协议定义的一个 Servlet 基类
 */
public class MyHttpServletRequest extends MyGenericServlet {
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        if (servletRequest instanceof HttpServletRequest) {
            HttpServletRequest request = (HttpServletRequest) servletRequest;
            if (servletResponse instanceof HttpServletResponse) {
                HttpServletResponse response = (HttpServletResponse) servletResponse;
                //调用下面的service 方法
                service(request, response);
            }
        }
    }

    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取请求方式
        String method = request.getMethod();

        //根据强求方式再调用对应的处理方法
        if (&quot;GET&quot;.equalsIgnoreCase(method)) {
            doGet(request, response);
        }
        if (&quot;POST&quot;.equalsIgnoreCase(method)) {
            doPost(request, response);
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {

    }

    public void doGet(HttpServletRequest request, HttpServletResponse response) {

    }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#servlet-%E7%AE%80%E4%BB%8B">Servlet 简介</a></li>
<li><a href="#servlet-%E4%BD%BF%E7%94%A8">Servlet 使用</a></li>
<li><a href="#servlet-%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1">Servlet 的四大域对象</a></li>
<li><a href="#servlet-%E7%9A%84%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91">Servlet 的转发和重定向</a></li>
<li><a href="#genericservlet-%E5%92%8C-httpservlet">GenericServlet 和 HttpServlet</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '78c231bbde878b725832',
    clientSecret: 'f84ba1a8636180bf745c1fe4b7242553439676f4',
    repo: 'jm0820.github.io',
    owner: 'jm0820',
    admin: ['jm0820'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://jm0820.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
